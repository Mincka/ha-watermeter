## ------------------------------------------------------
## Additional infos
## ------------------------------------------------------
## https://github.com/SzczepanLeon/esphome-components
## https://github.com/zdzichu6969/esphome-components
## ------------------------------------------------------

substitutions:
  device_name_short: "water-meter"
  friendly_name: "WasserzÃ¤hler"
  update_interval: 60s
  log_level: "INFO"
  appversion: "1.1.2"
  device_description: "Wemos D1 Min, CUL - CC1101, IZAR module (Diehl IZAR RC 868 I R4 PL)"

esphome:
  name: "water-meter"
  platform: ESP8266
  board: d1_mini
  esp8266_restore_from_flash: true
  arduino_version: recommended
  comment: ${device_description}
  project:
    name: "OE9psj.watermeter"
    version: ${appversion}
  build_path: ./build/${device_name_short}

# ----------------------------------------------------------------
# External components for wmbusmeter
# ----------------------------------------------------------------
  on_boot:
    priority: -500
    then:
      - logger.log:
          level: info
          format: "BOOTMESSAGE:${device_name_short} API is connected, Device ready!"
      - globals.set:
          id: boot_counter
          value: !lambda "return id(boot_counter)+=1;"

  on_shutdown:
    priority: 700
    then:
      - logger.log: ${device_name_short} is down!

# ----------------------------------------------------------------
# External components for wmbusmeter
# ----------------------------------------------------------------
#external_components:
#  - source: github://SzczepanLeon/esphome-components@main
#    components: [wmbus]

external_components:
  - source:
      type: local
      path: custom_components
    components: [wmbus]
  - source:
      type: local
      path: custom_components
    components: [backup]

#  - source:
#      type: local
#      path: custom_components
#    components: [water_statistics]
#    refresh: 0s
# ----------------------------------------------------------------
# Global variables
# ----------------------------------------------------------------
globals:
  - id: boot_counter
    type: int
    restore_value: yes
    initial_value: "0"

  - id: last_value
    type: float
    restore_value: yes
    initial_value: "0.00"

  - id: current_value
    type: float
    restore_value: yes
    initial_value: "0.00"

  - id: hour_value
    type: float
    restore_value: yes
    initial_value: "0.00"

  - id: daily_value
    type: float
    restore_value: yes
    initial_value: "0.00"

  - id: yesterday_value
    type: float
    restore_value: yes
    initial_value: "0.00"
  - id: week_value
    type: float
    restore_value: yes
    initial_value: "0.00"

  - id: month_value
    type: float
    restore_value: yes
    initial_value: "0.00"

  - id: year_value
    type: float
    restore_value: yes
    initial_value: "0.00"

  - id: lastmonth_value
    type: float
    restore_value: yes
    initial_value: "0.00"

## ---------------------------------------------------
## WIFI Settings
## ---------------------------------------------------
wifi:
  networks:
    - ssid: !secret ssid1_name
      password: !secret ssid1_pswd
    - ssid: !secret ssid2_name
      password: !secret ssid2_pswd
  domain: !secret domain

# The captive portal component in ESPHome is a fallback mechanism for
# when connecting to the configured WiFi fails.
captive_portal:

logger:
  id: appslogger
  level: ${log_level}
  logs:
     wmbus_sensor.component: ${log_level}
     wmbus.component: ${log_level}

## ---------------------------------------------------
# Enable Home Assistant API
## ---------------------------------------------------
# Homeassistant service call:
# service: esphome.water_meter_set_water_val
# data:
#  water_val_hour: 0.03
#  water_val_day: 0.248
#  water_val_yesterday: 0.178
#  water_val_week: 0.248
#  water_val_month: 1.94
#  water_val_year: 14.256
#  water_val_lastmonth: 9.59
## ---------------------------------------------------
api:
  id: espapiwm
  port: 6053
  reboot_timeout: 0s
  services:
    - service: set_water_val
      variables:
        water_val_hour: float
        water_val_day: float
        water_val_yesterday: float
        water_val_week: float
        water_val_month: float
        water_val_year: float
        water_val_lastmonth: float
      then:
        - globals.set:
            id: hour_value
            value: !lambda |-
              if((water_val_hour) and (water_val_hour)>0.001){
                ESP_LOGI("main", "Set hourly value to: %f", water_val_hour);
                return (water_val_hour);
              }else{  
                ESP_LOGI("main", "Skip setting hourly value");
                return id(hour_value);
              };
              id(waterhour).publish_state(id(hour_value));
        - globals.set:
            id: daily_value
            value: !lambda |-
              if((water_val_day) and (water_val_day)>0.001){
                ESP_LOGI("main", "Set daily value to: %f", water_val_day);
                return (water_val_day);
              }else{  
                ESP_LOGI("main", "Skip setting hourly value");
                return id(hour_value);
              };
              id(waterhour).publish_state(id(daily_value));
        - globals.set:
            id: yesterday_value
            value: !lambda |-
              if((water_val_yesterday) and (water_val_yesterday)>0.001){
                ESP_LOGI("main", "Set yesterday value to: %f", water_val_yesterday);
                return (water_val_yesterday);
              }else{  
                ESP_LOGI("main", "Skip setting yesterday value");
                return id(yesterday_value);
              };
              id(waterhour).publish_state(id(hour_value));
        - globals.set:
            id: week_value
            value: !lambda |-
              if((water_val_week) and (water_val_week)>0.001){
                ESP_LOGI("main", "Set weekly value to: %f", water_val_week);
                return (water_val_week);
              }else{  
                ESP_LOGI("main", "Skip setting weekly value"); 
                return id(week_value);
              };
              id(waterhour).publish_state(id(week_value));
        - globals.set:
            id: month_value
            value: !lambda |-
              if((water_val_month) and (water_val_month)>0.001){
                ESP_LOGI("main", "Set last montj value to: %f", water_val_month);
                return (water_val_month);
              }else{  
                ESP_LOGI("main", "Skip setting monthly value"); 
                return id(week_value);
              };
              id(waterhour).publish_state(id(month_value));
        - globals.set:
            id: lastmonth_value
            value: !lambda |-
              if((water_val_lastmonth) and (water_val_lastmonth)>0.001){
                ESP_LOGI("main", "Set last month value to: %f", water_val_lastmonth);
                return (water_val_lastmonth);
              }else{  
                ESP_LOGI("main", "Skip setting last month value"); 
                return id(lastmonth_value);
              };
              id(waterhour).publish_state(id(lastmonth_value));
        - globals.set:
            id: year_value
            value: !lambda |-
              if((water_val_year) and (water_val_year)>0.001){
                ESP_LOGI("main", "Set last yearly value to: %f", water_val_year);
                return (water_val_year);
              }else{  
                ESP_LOGI("main", "Skip setting last yearly value"); 
                return id(week_value);
              };
              id(waterhour).publish_state(id(year_value));                           
        
        - logger.log:
            format: "All new Values set: hour: %.1f, day: %.1f, week: %.1f, month: %.1f, lastmonth: %.1f, year: %.1f"
            args: [ 'id(hour_value)', 'id(daily_value)', 'id(week_value)', 'id(month_value)', 'id(lastmonth_value)', 'id(year_value)']


## ---------------------------------------------------
## OTA Updates
## ---------------------------------------------------
ota:
  password: !secret ota_pswd
  on_error:
    then:
      - logger.log:
          format: "OTA update error %d"
          args: ["x"]

## ----------------------------------------------------------------------
## LOCAL WEBSERVER Settings, local settings - no internet
## Include supporting javascript locally allowing it to work
## without internet access.
## ----------------------------------------------------------------------
web_server:
  port: 80
  version: 2
  local: true

## ---------------------------------------------------
## SNTP Time server
## ---------------------------------------------------
time:

  - platform: sntp
    id: sntp_time
    timezone: Europe/Berlin
    servers:
      - 0.at.pool.ntp.org
      - 0.pool.ntp.org
      - 1.pool.ntp.org

    on_time_sync:
      then:
        - logger.log: "Synchronized sntp clock"

    on_time:
      - seconds: 0
        minutes: 0
        then:
          - globals.set:
              id: hour_value
              value: "0.00"
          - lambda: id(waterhour).publish_state(id(hour_value));
          - logger.log: Reset value hour, starting next hour

      - seconds: 0
        minutes: 0
        hours: 0
        then:                    
          - lambda: id(yesterday_value)=id(daily_value);
          - lambda: id(wateryesterday).publish_state(id(yesterday_value));
          - logger.log: set value water yesterday
          - lambda: id(daily_value)=0.00;
          - lambda: id(waterday).publish_state(id(daily_value));          
          - logger.log: Reset value daily, starting new day

      - seconds: 0
        minutes: 0
        hours: 0
        days_of_week: MON
        then:
          - globals.set:
              id: week_value
              value: "0.00"
          - lambda: id(waterweek).publish_state(id(week_value));
          - logger.log: Reset value weekly, starting new week

      - seconds: 0
        minutes: 0
        hours: 0
        days_of_month: 1
        then:
          - globals.set:
              id: month_value
              value: "0.00"
          - lambda: id(watermonth).publish_state(id(month_value));
          - lambda: |-
              if(id(waterdisplay).state){
                id(lastmonth_value)=id(waterdisplay).state;
              }
          - logger.log: Reset value monthly, starting new month

      - seconds: 0
        minutes: 0
        hours: 0
        days_of_month: 1
        months: JAN
        then:
          - globals.set:
              id: year_value
              value: "0.00"
          - lambda: id(wateryear).publish_state(id(year_value));
          - logger.log: Reset value yearly, starting new year

## ---------------------------------------------------
## WMBUS DEVICE D1MINI WEMOS
## ---------------------------------------------------
wmbus:
  ## connction to CC1101
  mosi_pin: GPIO13 #D7  Attached to Hardware SPI controller MOSI SPI Interface
  miso_pin: GPIO12 #D6  Attached to Hardware SPI controller MISO SPI Interface
  clk_pin: GPIO14  #D5  Attached to Hardware SPI controller CLK 
  cs_pin: GPIO15   #D8  Controls Boot Mode; Attached to Hardware SPI controller CS SPI Interface 10k Pull-Down
  gdo0_pin: GPIO04 #D2  High Impedance 
  gdo2_pin: GPIO05 #D1  High Impedance

  ## led_blink_time (Optional): How long LED will stay ON. Defaults to 300 ms.
  led_pin: GPIO02  ## D4 Build_in LED
  led_blink_time: "1s" 
  
  ## Component to receive wMBus frame (via CC1101) and send it via TCP or UDP to wmbusmeters (as HEX or rtl-wmbus format).
  ## On client side you can use netcat to receive packets: nc -lku 7337
  ## wmbusmeters.conf: device=rtlwmbus:CMD(nc -lku 7337)
  ## HA_ADDON: https://github.com/SzczepanLeon/esphome-components/blob/main/docs/wmbusgw.md
  # clients:
  #   - name: "wmbusmeters"
  #     ip_address: "10.1.1.217"
  #     port: 7227
  #     format: rtlwMBus
  #     transport: UDP



## Save your ESPHome device configuration in firmware and and recover it if you lost source files.
## Just download it from `http://yourdevice.local/config.yaml`
## WARNING: You should backup your all your files, this solution only for emergency purpose. 
## I am not responsible for the loss or inability to recover data.
## WARNING: Stored configuration is the same as shown by `esphome config` command. 
## It is fully worked but not the same as your original sources.
## WARNING: Command line substitutions, custom components and includes are not supported yet!
backup:
  auth:
    username: !secret web_username
    password: !secret web_password
  force_update: false

## ---------------------------------------------------
## SWITCHES
## ---------------------------------------------------
switch:

  - platform: template
    name: Reset Boot Counter
    turn_on_action:
      then:
        - lambda: |-
            id(boot_counter) = 0;
            id(bootcounter).update();
        - logger.log: ${device_name_short} reset boot counter o.k!

  - platform: template
    name: Reset values
    turn_on_action:
      then:
        - lambda: |-
            id(boot_counter) = 0;
            id(hour_value) = 0.00;
            id(daily_value) = 0.00;
            id(week_value) = 0.00;
            id(month_value) = 0.00;
            id(year_value) = 0.00;
        - logger.log: all values reset!

  - platform: restart
    name: "Restart"
    id: restart_switch

## The debug component can be used to debug problems with ESPHome.
## debug:
##  update_interval: 5s

## ---------------------------------------------------
## SENSORS
## ---------------------------------------------------
sensor:

  - platform: wmbus
    name: "Wasseruhr Anzeige"
    id: "waterdisplay"
    meter_id: !secret watermeterId
    type: izar
    unit_of_measurement: "mÂ³"
    state_class: total_increasing
    device_class: "water"
    accuracy_decimals: 3
    on_value:
      then:
        - lambda: |-
            if (id(last_value) > 0.00 && (id(last_value)!=id(waterdisplay).state)) {                          
              id(current_value)=id(waterdisplay).state-id(last_value);
              id(watercurrent).publish_state(id(current_value));
              id(hour_value)+=id(waterdisplay).state-id(last_value);
              id(waterhour).publish_state(id(hour_value));
              id(daily_value)+=id(waterdisplay).state-id(last_value);
              id(waterday).publish_state(id(daily_value));
              id(week_value)+=id(waterdisplay).state-id(last_value);
              id(waterweek).publish_state(id(week_value));
              id(month_value)+=id(waterdisplay).state-id(last_value);
              id(watermonth).publish_state(id(month_value));
              id(year_value)+=id(waterdisplay).state-id(last_value);
              id(wateryear).publish_state(id(year_value));
              ESP_LOGI("main", "Set current value to: %f", id(watercurrent));
            }else{
              id(current_value) = 0.00;
              id(watercurrent).publish_state(id(current_value));
              ESP_LOGI("main", "Reset current value to: %f", id(watercurrent));
            }
            id(last_value)=id(waterdisplay).state;

  - platform: wifi_signal
    name: WiFi Signal
    id: "wifisignal"
    update_interval: 30s

  - platform: template
    name: Wasser Aktuell
    id: "watercurrent"
    accuracy_decimals: 3
    unit_of_measurement: "mÂ³"
    state_class: "measurement"
    device_class: "water"
    lambda: |-
      return (id(current_value));

  - platform: template
    name: Wasser Stunde
    id: "waterhour"
    accuracy_decimals: 3
    unit_of_measurement: "mÂ³"
    state_class: total_increasing
    device_class: "water"
    lambda: |-
      return (id(hour_value));

  - platform: template
    name: Wasser Tag
    id: "waterday"
    accuracy_decimals: 3
    unit_of_measurement: "mÂ³"
    device_class: "water"
    state_class: total_increasing
    lambda: |-
      return (id(daily_value));
      
  - platform: template
    name: Wasser Gestern
    id: "wateryesterday"
    accuracy_decimals: 3
    unit_of_measurement: "mÂ³"
    device_class: "water"
    state_class: total_increasing
    lambda: |-
      return (id(yesterday_value));

  - platform: template
    name: Wasser Woche
    id: "waterweek"
    accuracy_decimals: 3
    unit_of_measurement: "mÂ³"
    device_class: "water"
    state_class: total_increasing
    lambda: |-
      return (id(week_value));

  - platform: template
    name: Wasser Monat
    id: "watermonth"
    accuracy_decimals: 3
    unit_of_measurement: "mÂ³"
    state_class: total_increasing
    device_class: "water"
    lambda: |-
      return (id(month_value));

  - platform: template
    name: Wasser Jahr
    id: "wateryear"
    accuracy_decimals: 3
    unit_of_measurement: "mÂ³"
    state_class: total_increasing
    device_class: "water"
    lambda: |-
      return (id(year_value));

  - platform: template
    name: Wasser letzer Monat
    id: "waterlastmonth"
    accuracy_decimals: 3
    unit_of_measurement: "mÂ³"
    state_class: "measurement"
    device_class: "water"
    lambda: |-
      return (id(lastmonth_value));

  - platform: template
    name: Boot counter
    id: bootcounter
    accuracy_decimals: 0
    entity_category: "diagnostic"
    lambda: |-
      return (id(boot_counter));

  - platform: uptime
    name: Uptime
    id: uptime_sensor
    internal: true
    update_interval: ${update_interval}
    on_raw_value:
      then:
        - text_sensor.template.publish:
            id: uptime_human
            state: !lambda |-
              int seconds = round(id(uptime_sensor).raw_state);
              int days = seconds / (24 * 3600);
              seconds = seconds % (24 * 3600);
              int hours = seconds / 3600;
              seconds = seconds % 3600;
              int minutes = seconds /  60;
              seconds = seconds % 60;
              return (
                (days ? String(days) + "d " : "") +
                (hours ? String(hours) + "h " : "") +
                (minutes ? String(minutes) + "m " : "") +
                (String(seconds) + "s")
              ).c_str();

## ---------------------------------------------------
## BINARY SENSOR
## ---------------------------------------------------
binary_sensor:

  - platform: template
    name: Status Led
    id: statusled
    entity_category: "diagnostic"
    lambda: 'return id(current_value) > 0;'

## ---------------------------------------------------
## TEXT SENSOR
## ---------------------------------------------------
text_sensor:

  - platform: version
    name: Version
    id: appver
    entity_category: "diagnostic"

  - platform: template
    name: Online seit
    id: uptime_human
    icon: mdi:clock-start
    entity_category: "diagnostic"

  - platform: template
    name: Timestamp
    id: systime
    entity_category: "diagnostic"
    lambda: char str[20];
      time_t currTime = id(sntp_time).now().timestamp;
      strftime(str, sizeof(str), "%Y-%m-%dT%H:%M:%S", localtime(&currTime));
      return (std::string) str;

  - platform: template
    id: watermeterdata
    update_interval: ${update_interval}
    lambda: |-
        char buf[512];
        sprintf(buf, "%.3f|%.3f|%.3f|%.3f|%.3f|%.3f|%.3f|%.3f|%s",
               id(waterdisplay).state,
               id(current_value),
               id(hour_value),
               id(daily_value),
               id(week_value),
               id(month_value),
               id(lastmonth_value),
               id(year_value),
               id(systime).state.c_str()
               );
        std::string s = buf;
        return s;
